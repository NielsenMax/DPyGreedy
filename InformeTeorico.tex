\documentclass[10pt]{article}
\usepackage[cp1252]{inputenc}
\usepackage{graphicx}
\usepackage{vmargin}
\usepackage{fancyhdr}
\usepackage[T1]{fontenc}
\usepackage{multirow}
\usepackage{tikz}
\usepackage[spanish,es-noshorthands]{babel}
\usepackage{minted}
\setpapersize{A4}
\setmargins{2cm}		%margen izquierdo
{3cm}				%margen superior
{17.5cm}				%anchura del texto
{23.3cm}				%altura del texto
{10pt}				%altura de los encabezados
{1cm}				%espacio entre el texto y los encabezados
{10pt}				%altura del pie de pagina
{0.5cm}				%espacio entre el texto y el pie de pagina

\begin{document}
	%%%%%%%%%%%%%%%Pie de Pagina y Encabezado
	\pagestyle{fancy}
	\renewcommand{\headrulewidth}{0.4pt}
	\renewcommand{\footrulewidth}{0.4pt}
	\fancyhead[LO,LE]{Algoritmos y Estructuras de Datos Avanzadas}
	\fancyfoot[C]{15/10/2019}
	\fancyhead[R]{Nielsen Maximiliano, Uliassi Manuel}
	\fancyfoot[L]{6to Informatica}
	\fancyfoot[FR] {P\'agina \thepage}
	%%%%%%%%%%%%%%%Pie de Pagina y Encabezado
	
	%%%%%%%%%%%%%%%%%%%%%PORTADA
	\begin{titlepage}
		\null
		\vspace{4cm}
		\centering
		{\Huge Programaci\'on Din\'amica\\ y Greedy}
		
		\vspace{0.2cm}
		
		{\LARGE Algoritmos y Estructuras de Datos Avanzadas}
		
		\vspace{0.2cm}
		
		{\large Informe Te\'orico}
		
		\vspace{1.5cm}
		
		{\LARGE Nielsen Maximiliano - Uliassi Manuel}
		
		\vspace{0.15cm}
		
		{\large Docente: Juan Manuel Rabasedas}
		
		\vspace{0.15cm}
		
		{\large 6to Inform\'atica}
		
		\vspace{0.15cm}
		
		{\large Instituto Politecnico Superior Gral. San Martin}
		\vfill
		
	\end{titlepage}
	%%%%%%%%%%%%%%%%%%%%%PORTADA
	\begin{center}
		\section*{\LARGE Informe Te\'orico}
	\end{center}
	\subsection*{Objetivo}
	El objetivo de este Informe Teorico es explicar y complementar con teoria la resoluci\'on de los siguientes problemas de Programaci\'on Din\'amica y Algoritmos Greedy asignados.
	\subsection*{Problema de Programaci\'on Din\'amica}
	Dado un arreglo $A[a_1,...,a_n]$ de enteros no negativos, encontrar una subsecuencia $A[a_1,...,a_j]$ de tama\~no m\'aximo tal que: i = j  \'o  i = j + 1 \'o para todo $r \geq 0$, valen las desigualdades $a_{i+r} \geq \sum_{k=i+r+1}^{j-r-1}a_k $ y $ a_{j-r} \geq \sum_{k=i+r+1}^{j-r-1}a_k$.
	Por ejemplo, en el arreglo [1, 8, 2, 1, 3, 9, 10] la subsecuencia [8, 2, 1, 3, 9] cumple la propiedad, ya que $ 8 \geq 2 + 1 + 3 $ y $ 9 \geq 2 + 1 + 3 (r=0) $ y adem\'as $ 2 \geq 1 $ y $ 3 \geq 1 $ (r=1).
	Escriba un algoritmo de programaci\'on din\'amica bottom-up para resolver el problema. La salida del algoritmo son dos \'indices $ i \leq j $ tales que $A[a_i,...,a_j]$ es una subsecuencia de tama\~no m\'aximo.
	\subsection*{Problema de Algoritmos Greedy}
	Dado un  \'arbol con pesos no negativos en los lados, se quiere resolver el problema de encontrar el m\'inimo camino desde la ra\'iz hasta una hoja. Considere el algoritmo greedy que, partiendo desde la ra\'iz como nodo actual, elige siempre el lado \textit{l} con menor peso. El nuevo nodo actual es
	el apuntado por \textit{l}. El algoritmo termina cuando el nodo actual es una hoja.
	\begin{itemize}
		\item Encuentre un ejemplo en que el camino encontrado por el algoritmo no es \'optimo.
		\item Encuentre una condici\'on \textit{C} sobre \'arboles de manera tal que, si un \'arbol cumple con \textit{C}, entonces el camino encontrado por el algoritmo en ese \'arbol es optimo. El \'arbol que se muestra en la figura debe cumplir la condici\'on. Sugerencia: piense en \'arboles con pesos muy grandes cerca de la ra\'iz y pesos muy chico cerca de las hojas.
		\newline
		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%ARBOL
		\tikzset{
			treenode/.style = {shape=circle,draw, align=center,bottom color=blue!30, top color=blue!30},
			root/.style     = {treenode, font=\large,},
			env/.style      = {treenode, font=\large},
			dummy/.style    = {circle,draw}
		}
		\begin{center}
			\begin{tikzpicture}
			[
			sibling distance        = 3.5cm,
			level distance          = 2cm,
			edge from parent/.style = {draw, -latex},
			every node/.style       = {font=\large},
			]
			\node [root] {A}
			child { node [env] {B} [sibling distance=2cm]
				child { node [env] {E} 
					edge from parent node [left] {1}
				}
				child { node [env] {F} 
					edge from parent node [right] {2}
				}
				edge from parent node [above] {0}
			}
			child { node [env] {C} [sibling distance=2cm]
				child { node [env] {H} 
					edge from parent node [left] {1}
				}
				child { node [env] {I} 
					edge from parent node [right] {1}
				}
				edge from parent node [left] {3}
			}
			child { node [env] {D} [sibling distance=2cm]
				child { node [env] {J}
					edge from parent node [left] {2}
				}
				child { node [env] {K} 
					edge from parent node [right] {}
				}
				edge from parent node [above] {7}
			};
			\end{tikzpicture}
		\end{center}
		%%%%%%%%%%%%%%%%%%%%%%%%%
		\item Pruebe que la condici\'on encontrada en el punto anterior asegura que el algoritmo encuentra el \'optimo.
	\end{itemize}
	%%%%%%%%%%%%%%%%%%%%%%%%%ARBOL2
	\newpage
	\section*{\LARGE Problema Programaci\'on Din\'amica}
	\subsection*{Conceptos B\'asicos}
	Para resolver este problema utilizamos un algoritmo Bottom-Up, lo que hacemos es primero resolver los problemas m\'as chicos y combinar estas resoluciones para poder resolver los problemas m\'as grandes. Primero vamos a dejar en claro algunas definiciones que vamos a usar en la aplicaci\'on del algoritmo:
La secuencia principal, aquella que se ingresa, la vamos a llamar \textbf{S}, la cantidad de elementos de \textbf{S} se va a llamar \textbf{N}.
El enunciado hace referencia a tres condiciones posibles para que la subsecuencia de \textbf{S} cumpla con la propiedad correspondiente, a estas condiciones les asignamos un nombre a cada una. Por un lado tenemos la \textbf{C1}, es cuando dada la subsecuencia A[ai,...,aj] j es igual a i, por otro lado tenemos la \textbf{C2}, es cuando dada la subsecuencia A[ai,...,aj] i es igual a j+1, y por \'ultimo tenemos la \textbf{C3}, se da cuando tenemos una subsecuencia y para todo r â‰¥ 0, valen las desigualdades $a_{i+r} \geq \sum_{k=i+r+1}^{j-r-1}a_k $ y $ a_{j-r} \geq \sum_{k=i+r+1}^{j-r-1}a_k$.
Cuando una subsecuencia de \textbf{S} cumple con \textbf{C1}, con \textbf{C2} o con \textbf{C3} esta va a  pasar a llamarse \textbf{SCC}. La \textbf{SCC} de mayor longitud va a llamarse \textbf{SCCO} y va a ser la subsecuencia que el algoritmo devuelve como resultado.
	\subsection*{Explicaci\'on del Algoritmo}
Para el inicio del algoritmo vamos a determinar dos propiedades, la primera es que si una subsecuencia de \textbf{S} es de longitud uno entonces es una \textbf{SCC} gracias a que cumple con la \textbf{C1} y la segunda es que si una subsecuencia de \textbf{S} es de longitud dos entonces es una \textbf{SCC} gracias a que cumple con la \textbf{C2}. Una vez determinado esto vamos a empezar con el algoritmo.\\
El primer paso va a ser seleccionar todas las subsecuencias de \textbf{S} de longitud tres y comprueba si los elementos de los extremos son mayores o iguales al elemento del medio  y si se cumple esta condici\'on entonces se especifica en una matriz cual cumple con esta condici\'on y cu\'al no.\\
El siguiente paso consiste en comprobar cuales subsecuencias de \textbf{S} de longitud cuatro cumplen la propiedad en que los extremos son mayores o iguales a la sumatoria de los elementos que no son de los extremos, la \textbf{C3},y distinguir en la matriz cuales cumplen con esto y cuales no.\\
Cuando llegamos al tercer paso, el paso para analizar las subsecuencias de longitud 5, vamos a comprobar para todas las subsecuencias de longitud 5 si los elementos de los extremos son mayores o iguales a la sumatoria de los elementos que no est\'an en los extremos y comprobar que suceda lo mismo en la subsecuencia conformada por los elementos que no se encuentran en los extremos, la \textbf{C3},  pero como anteriormente ya calculamos aquellas subsecuencias que pueden ser conformadas por estos elementos que no se encuentran en los extremos entonces vamos a tener que buscar la respuesta a este c\'alculo en la matriz en donde se guardaron los datos anteriormente.\\
Por ejemplo: En el caso de la Secuencia [1,8,2,1,3,9,10] en el tercer paso analizando la subsecuencia [8,2,1,3,9] cuando se tenga que comprobar si la subsecuencia [2,1,3] cumple con la \textbf{C3} este c\'alculo ya fue realizado y almacenado en la matriz mencionada anteriormente, entonces solo hay que buscar este resultado y no calcularlo.\\

Aunque parezca ser un algoritmo de fuerza bruta, este aprovecha los c\'alculos que se llevan a cabo durante el proceso utiliz\'andolos m\'as adelante. Esta es la diferencia principal entre resolver este problema con fuerza bruta y resolverlo con Bottom-Up.

\subsection*{Utilizaci\'on de matriz}
Utilizaremos la lista [1,8,2,1,3,9,10] de ejemplo como \textbf{\textit{S}}.
 Para comenzar con la inicializaci\'on crearemos una matriz identidad de 7 por 7 (N*N).
Las casillas de valor uno que se encuentran a lo largo de la diagonal de la matriz representan que para las subsecuencias definidas entre las posiciones i y j de S (siendo i y j las coordenadas de la casilla) la \textbf{\textit{SCC}} contenida en dicha subsecuencia es de longitud uno.\\
\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
 & 1 & 8 & 2 & 1 & 3 & 9 & 10 \\ \hline
 i/j & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\ \hline
 1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
 2 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ \hline
 3 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ \hline
 4 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ \hline
 5 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ \hline
 6 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ \hline
 7 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \hline
\end{tabular}
\end{center}
\end{table}
\newpage
Una vez calculada la diagonal comenzar\'a el algoritmo, siguiendo el siguiente pseudoc\'odigo:\\

condicion i j S matriz:
\newline
S[i] >= sum S[i+1 ... j-1] and S[j] >= sum S[i+1 ... j-1] and  matriz[i+1][j-1] > max(matriz[ i+1 ][ j-2 ],matriz[ i+2 ][ j -1 ],matriz[ i+2 ][ j-2 ])
\newline
if condicion i j S matriz:
\newline
		\hspace{3cm} matriz[i][j] = matriz[i+1][j-1] + 2
		\newline
	else:
	\newline
	\hspace{3cm} matriz[i][j] = max(matriz[ i ][ j-1 ],matriz[ i+1 ][ j ],matriz[ i+1 ][ j-1 ])
\newline

Primero tomara una casilla y sus coordenadas (i,j). Comprobar\'a si el elemento de \textbf{\textit{S}} en i y el elemento de \textbf{\textit{S}} en j son mayores o iguales a la sumatoria de los elementos de \textbf{\textit{S}} comprendidos entre i y j, tambi\'en comprobaremos si la subsecuencia sin los elementos i y j de \textbf{\textit{S}} tambi\'en es una \textbf{\textit{SCC}}. Si esto se cumple implica que la subsecuencia de \textbf{\textit{S}} delimitada por i y j es una \textbf{\textit{SCC}}, por ende esta se pudo extender una vez m\'as que la anterior encontrada. Aqu\'i es donde podemos observar la ventaja de nuestro algoritmo DP frente a la fuerza bruta. No hace falta calcular si la condici\'on C3 se cumple hacia dentro recursivamente, dado que ya lo tenemos calculado en las casillas aleda\~nas. \'unicamente tenemos que tomar la subsecuencia sin los elementos extremos y a\~nadirle 2, la longitud de esta se encuentra en la casilla (i+1,j-1).\\
 Si la comprobaci\'on resultara falsa el algoritmo buscar\'a cual es el mayor valor entre las casillas a su izquierda, debajo y debajo a su izquierda de esta. Almacena este valor en vez de la nueva longitud de la \textbf{\textit{SCC}}, ya que este valor ser\'a el valor de la \textbf{\textit{SCC}} contenida en esta subsecuencia delimitada por i y j.\\


\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
 & 1 & 8 & 2 & 1 & 3 & 9 & 10 \\ \hline
 i/j & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\ \hline
 1 & 1 & 2 & 2 & 2 & 4 & 5 & 5 \\ \hline
 2 & 0 & 1 & 2 & 2 & 4 & 5 & 5 \\ \hline
 3 & 0 & 0 & 1 & 2 & 3 & 3 & 3 \\ \hline
 4 & 0 & 0 & 0 & 1 & 2 & 2 & 2 \\ \hline
 5 & 0 & 0 & 0 & 0 & 1 & 2 & 2 \\ \hline
 6 & 0 & 0 & 0 & 0 & 0 & 1 & 2 \\ \hline
 7 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \hline
\end{tabular}
\end{center}
\end{table}

Una vez calculada la matriz encontraremos la \textbf{\textit{SCCO}} en base a que la longitud de esta se encuentra almacena en la esquina superior derecha de la matriz, llamaremos a este valor E. Por lo tanto buscaremos en que casilla la \textbf{\textit{SCCO}} realiza su \'ultima extensi\'on.\\
Para eso nos fijamos cual es el mayor valor entre la casilla izquierda, la de debajo y la de debajo a la izquierda. Si el mayor valor coincide con E nos moveremos a esa casilla y volveremos a mirar las 3 casillas aleda\~nas. Si el valor es menor sabremos que en esa casilla la \textbf{\textit{SCCO}} realizo su ultima extension. Siguiendo esta recursi\'on de comprobar si el mayor valor aleda\~no es menor a E podremos encontrar facilmente que subsecuencia de \textbf{\textit{S}} es la \textbf{\textit{SCCO}}, ya que en las coordenadas i y j de la casilla en donde se realiza la \'ultima extensi\'on representan la posici\'on de inicio y la final de la subsecuencia de \textbf{\textit{S}} respectivamente.\\



	\subsection*{Prueba de optimalidad }
	Debemos probar que nuestra excursi\'on nos lleva a una soluci\'on \'optima
		\begin{center}
			DP[i,j] nos devuelve el largo de la SCC en la subsecuencia S[i..j]\\
	
	SCCO (S[i..j]) nos devuelve la SCCO de la subsecuencia S
		\end{center}

\begin{tabbing}
		Si \=S[i] >= Sum S[(i+1)...(j-1)] y S[j] >= Sum S[(i+1)...(j-1)]  con i = 1\\
	
		\>	Sea \=r[1..k] = SCCO (S[i..j]) con DP[i,j] = k \\
		
		\>\>	r[k] = S[j] y r[1] = S[i]
	\end{tabbing}      
	Si r[1..k] no incluye a S[i] y S[j] como su primer y \'ltimo elemento podr\'iamos extender a r ya que S[i] >= Sum S[(i+1)...(j-1)] y S[j] >= Sum S[(i+1)..(j-1)]\\
	Luego r[2..k-1] es una SCC de S[i+1...j-1]

\begin{center}
		Que me gustar\'ia que pase?\\
\end{center}
	Me gustar\'ia que:\\
	
	r[2..k-1] sea SCCO de S[i+1...j-1]
	
	Supongamos que \textbf{\textit{w}} es una SCC de m\'as larga  de S[i+1...j-1]\\
	
	Es decir que |w| > k - 2 \textit{(k - (1 + 1)  dado que es i + 1 y j - 1)}\\
	
	Luego concatenando w con r[k]
	\begin{center}
		[w[i]] ++ r[k] ++ w[j]
	\end{center}
	
	obtenemos una SCC de S[i..j] con | [w[i]] ++ r[k] ++ w[j] | > k
	\begin{center}
		Contradicci\'on!
	\end{center}
	
	\begin{flushleft}
		Entonces, DP[i+1,j-1] = k - 2 lo que implica que
	DP[i,j] = DP[i+1,j-1] + 2 en el caso S[1] >= Sum S[2..(j-1)] y S[j] >= Sum S[2..(j-1)]
	\end{flushleft}
	
	\begin{flushleft}
		Los otros casos son similares
	\end{flushleft}
	\subsection*{Implementaci\'on}
	Para la implementaci\'on utilizamos el m\'odulo de haskell Data.Matrix que implementa funciones \'utiles para trabajar con matrices.\\
	
	La funci\'on identity n crea una matriz de identidad de n por n.\\
	
	La funci\'on getElem j i mx obtiene el elemento (i,j) de la matriz mx.\\
	
	La funci\'on setElem a j i mx escribe el elemento (i,j) de la matriz mx con el valor a.\\
		\begin{minted}{haskell}
	import Data.Matrix

--Calcula el maximo entre 3 elementos
max3 :: Ord a => a -> a -> a -> a  
max3 a b c = if a >= b then 
    (if a >= c then a else 
    (if b >= c then b else c)) else 
    (if b >= c then b else c)

--Calcula el maximo entre 3 tuplas de 3 elementos y devuelve una tupla de 2 elementos
max3ij :: Ord a1 => (a1, a2, b) -> (a1, a2, b) -> (a1, a2, b) -> (a2, b)
max3ij (av, ai, aj) (bv , bi, bj) (cv, ci, cj) = if av >= bv then 
    (if av >= cv then (ai,aj) else 
    (if bv >= cv then (bi, bj) else (ci,cj))) else 
    (if bv >= cv then (bi,bj) else (ci,cj))

-- Chekea que la subsecuencia entre i y j sea una SCC en base a si fue extendida en la casilla (i,j)
cond2 :: Int -> Int -> Matrix Int -> Bool
cond2 i j mx |j <= 0    = True
             |otherwise = getElem i j mx > (max3 
                (getElem i (j-1) mx) 
                (getElem (i+1) j mx) 
                (getElem (i+1) (j-1) mx)) 

--Checkea que los elementos en las posiciones i y j sean maryores a la suma 
--de los elementos entre ellas y que la subsecuencia sin los elementos i y j es una SCC
cond :: (Ord a, Num a) => Int -> Int -> [a] -> Matrix Int -> Bool
cond i j orgn mx |j-i == 1 = True
                 |otherwise= let
                        f = [ x | (x,a) <- zip orgn [1..], a > i && a < j ]
                    in
                        (orgn!!(i-1) >= sum f) && (orgn!!(j-1) >= sum f) && cond2 (i+1) (j-1) mx
                 

--Corta una lista apartir de la posicion a hasta b
trim :: (Num a1, Enum a1, Ord a1) => a1 -> a1 -> [a2] -> [a2]
trim a b orgn = [ x | (x,i) <- zip orgn [1..], i >= a && i <= b ]

-- Calcula la matriz que permite hacer el calculo del algoritmo
-- bdp :: Int          Coordenada I
-- -> Int              Coordenada J
-- -> Int              Inicio, generalmente es 2
-- -> Int              Fin, Uno mas que el largo de la lista
-- -> [Int]            Lista de input
-- -> Matrix Int       Matriz en la q va la respuesta
bdp :: (Ord a, Num a) => Int -> Int -> Int -> Int -> [a] -> Matrix Int -> Matrix Int
bdp  i j b e orgn mx | (i == 1 && j == e)    = mx
bdp  i j b e orgn mx | i == e || j == e      = bdp 1 b (b+1) e orgn mx
bdp  i j b e orgn mx | otherwise             =
        if cond i j orgn mx
                then bdp (i+1) (j+1) b e orgn (setElem ((getElem (i+1) (j-1) mx)+2) (i,j) mx)
                else bdp (i+1) (j+1) b e orgn (setElem (max3
                    (getElem i (j-1) mx) 
                    (getElem (i+1) j mx) 
                    (getElem (i+1) (j-1) mx)) 
                    (i,j) mx)
        

-- Recorre la matriz generada por bdp para obtener la subsequencia 
-- adp :: Int       Coordenada I, tendria que ser 1
-- -> Int           Coordenada J, tendria que ser el largo de la lista
-- -> [Int]         Lista del input
-- -> Matrix Int    Matriz precalculada
-- -> Int           Longitud de la subsequencia, 
--                  elemento de la matriz en la posicion I = 1 y J = Largo de la lista
adp :: Ord t => Int -> Int -> [a] -> Matrix t -> t -> [a]
adp i j orgn mx last | last > (max3
                                (getElem i (j-1) mx) 
                                (getElem (i+1) j mx) 
                                (getElem (i+1) (j-1) mx)) 
                                = trim i j orgn
adp i j orgn mx last | otherwise = adp (fst maximum) (snd maximum) orgn mx last
        		where 	maximum = (max3ij 
        		                    ((getElem i (j-1) mx),i,j-1)    
        		                    ((getElem (i+1) j mx),i+1,j) 
        		                    ((getElem (i+1) (j-1) mx), i+1, j-1))
                        
-- Coordina bdp y adp
dp :: (Ord a, Num a) => [a] -> [a]
dp orgn =   let
    l = length orgn
    mx = bdp 1 2 2 (l+1) orgn (identity l)
    ms = getElem 1 l mx
    in
        adp 1 l orgn mx ms

 \end{minted}
 \subsection*{An\'alisis del costo de DP frente a Fuerza Bruta}
 Fuerza Bruta:\\
calcular si una subsecuencia cumple la condicion: \textbf{\textit{O($n^{2}$)}}\\
calcular todas las subsecuencias: \textbf{\textit{O($n^{2}$)}}\\
Costo total: \textbf{\textit{O($n^{4}$)}}\\
Programaci\'on Din\'amica:\\
calcular si una subsecuencia cumple la condici\'on: O(n)\\
calcular las subsecuencias: \textbf{\textit{O($n^{2}$)}}\\
Costo total: \textbf{\textit{O($n^{3}$)}}\\

Como podemos observar nuestro costo al implementar DP disminuye en un factor de N para el largo de la secuencia de entrada.

	%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\newpage
	\begin{center}
		\section*{\LARGE Problema Greedy}
	\end{center}
	\subsection*{No \'optimo}
	El algoritmo planteado no resulta \'optimo para cualquier tipo de \'arbol. Esto se puede ver en el siguiente ejemplo:\\
	\tikzset{
		treenode/.style = {shape=circle,draw, align=center,bottom color=blue!30, top color=blue!30},
		root/.style     = {treenode, font=\large,},
		env/.style      = {treenode, font=\large},
		dummy/.style    = {circle,draw}
	}
	\begin{center}
		\begin{tikzpicture}
		[
		sibling distance        = 3.5cm,
		level distance          = 2cm,
		edge from parent/.style = {draw, -latex},
		every node/.style       = {font=\large},
		]
		\node [root] {A}
		child { node [env] {B} [sibling distance=2cm]
			child { node [env] {C} 
				edge from parent node [left] {4}
			}
			child { node [env] {D} 
				edge from parent node [right] {5}
			}
			edge from parent node [above] {1}
		}
		child { node [env] {E} [sibling distance=2cm]
			child { node [env] {F} 
				edge from parent node [left] {1}
			}
			child { node [env] {G} 
				edge from parent node [right] {2}
			}
			edge from parent node [left] {2}
		}
		child { node [env] {H} [sibling distance=2cm]
			child { node [env] {I}
				edge from parent node [left] {2}
			}
			child { node [env] {J} 
				edge from parent node [right] {3}
			}
			edge from parent node [above] {7}
		};
		\end{tikzpicture}
	\end{center}
	El algoritmo para este \'arbol devuelve el camino \textit{\{A,B,C\}} que tiene un peso de 5 mientras que la resoluci\'on del problema da como resultado el camino \textit{\{A,E,F\}}, que tiene peso de 3.
	\\
	El problema m\'as frecuente de este algoritmo es que al no tener en cuenta el \'arbol en su totalidad opta por una arista liviana con hijas pesadas cuando la opci\'on m\'as \'optima es optar por una arista pesada con hijas livianas.
	\subsection*{Condiciones espec\'ificas}
	El algoritmo no funciona para cualquier tipo de \'arbol. Establecimos dos condiciones espec\'ificas que debe cumplir un \'arbol para que el algoritmo de como resultado el m\'inimo camino de este.
	\\
	Una rama de un \'arbol es el camino desde la ra\'iz del mismo hacia cualquiera de sus hojas, el peso de una rama se calcula sumando el valor de cada arista por la que pasa la rama para poder llegar a la hoja correspondiente.
	\\\\
	\textbf{\textit{Condici\'on 1 (C1)}}\\
	La primera condici\'on que debe complir el arbol es que las aristas hermanas deben estar ordenadas de forma creciente.
	\\\\
	\textbf{\textit{Condici\'on 2 (C2)}}\\
	La segunda condici\'on que debe cumplir el \'arbol es que las ramas de este tienen que estar ordenadas de manera creciente seg\'un su peso.
	\\\\
	
	La condici\'on \textbf{\textit{C2}} implica que el camino de la ra\'iz a una hoja m\'as liviano siempre ser\'a el que se encuentre m\'as a la izquierda. Sin embargo esta condici\'on por si sola no garantiza que tomando siempre la arista de menor peso encontraremos la rama de menor peso.\\
	Veamos el siguiente ejemplo:
	\tikzset{
		treenode/.style = {shape=circle,draw, align=center,bottom color=blue!30, top color=blue!30},
		root/.style     = {treenode, font=\large,},
		env/.style      = {treenode, font=\large},
		dummy/.style    = {circle,draw}
	}
	\begin{center}
		\begin{tikzpicture}
		[
		sibling distance        = 3.5cm,
		level distance          = 2cm,
		edge from parent/.style = {draw, -latex},
		every node/.style       = {font=\large},
		]
		\node [root] {A}
		child { node [env] {B} [sibling distance=2cm]
			child { node [env] {C} 
				edge from parent node [left] {1}
			}
			child { node [env] {D} 
				edge from parent node [right] {3}
			}
			edge from parent node [above] {9}
		}
		child { node [env] {E} [sibling distance=2cm]
			child { node [env] {F} 
				edge from parent node [left] {4}
			}
			child { node [env] {G} 
				edge from parent node [right] {5}
			}
			edge from parent node [left] {7}
		}
		child { node [env] {H} [sibling distance=2cm]
			child { node [env] {I}
				edge from parent node [left] {6}
			}
			child { node [env] {J} 
				edge from parent node [right] {7}
			}
			edge from parent node [above] {10}
		};
		\end{tikzpicture}
	\end{center}
	Si bien el \'arbol se encuentra ordenado por ramas, tomar las aristas de menor peso no nos lleva a la rama de menor peso. Tomar las aristas de menor peso resultar\'ia en el camino \textbf{\textit{\{A,E,F\}}} con un costo igual a 11. Mientras que el camino m\'as liviano de la ra\'iz a una hoja se encuentra a la izquierda, \textbf{\textit{\{A,B,C\}}} con un costo de 10.\\
	Esto muestra que adem\'as se debe cumplir la condici\'on \textbf{\textit{C1}}.
	Esta condici\'on establece que las aristas hermanas deben estar ordenadas por peso de forma creciente. Esto implica que la arista m\'as a la izquierda siempre ser\'a la de menor peso. A su vez, gracias a la condici\'on \textbf{\textit{C2}}, la rama m\'as izquierda ser\'a la de menor peso. \\
	De esta forma se prueba que siempre la rama m\'as izquierda contendr\'a las aristas de menor peso con respecto a sus hermanas y adem\'as llevar\'a al camino m\'as liviano hacia una hoja. \\
	Probando as\'i que la elecci\'on de la arista m\'as liviana siempre llevar\'a a la rama de menor peso, es decir al camino de menor peso de la ra\'iz a una hoja, siempre que el \'arbol cumpla con las condiciones \textbf{\textit{C1}} y \textbf{\textit{C2}}.
	\subsection*{Implementaci\'on del algoritmo Greedy}
	\begin{minted}{haskell}
	-- El Int es para la arista que da origen al nodo, en el caso de la raiz es 0
	data Tree a = N Int a [Tree a] deriving (Show)
	
	-- Funcion que toma una listas de arboles y devuelve el arbol cuya
	--arista que le da origen es la de menor peso
	tmin :: [Tree a] -> Tree a
	tmin [x] = x
	tmin (x:xs) = let
	minim (x@(N xe xa xs)) (y@(N ye ya ys)) | xe > ye  = y
	| xe <= ye = x
	in
	minim x (tmin xs) 
	
	-- Funcion que ejecuta el algoritmo Greedy
	greedy :: Tree a -> [a]
	greedy (N e a []) = [a]
	greedy (N e a xs) = a : greedy (tmin xs)
	
	\end{minted}
	%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}






































